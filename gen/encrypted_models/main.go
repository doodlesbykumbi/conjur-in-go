package main

import (
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"html/template"
	"os"
	"reflect"
	"strings"
)

var tpl = `// Auto-generated by gen/encrypted_models/main.go
package {{.Package}}

import (
	"fmt"

	"gorm.io/gorm"

	"conjur-in-go/pkg/slosilo"
)

{{- range $encryptedStruct := .EncryptedStructs -}}
{{- $structName := $encryptedStruct.StructName}}

func (s *{{$structName}}) BeforeCreate(tx *gorm.DB) error {
	encrypt := s.getCipherForDb(tx).Encrypt
{{ range $encryptedField := $encryptedStruct.Fields -}}
	{{- $fieldName := $encryptedField.FieldName}}
	{{- $aadFieldName := $encryptedField.AadFieldName}}
	plain{{$fieldName}} := s.{{$fieldName}}
	encrypted{{$fieldName}}, err := encrypt([]byte(s.{{$aadFieldName}}), plain{{$fieldName}})
	if err != nil {
		return fmt.Errorf("{{$fieldName}} encryption failed for {{$aadFieldName}}=%q", s.{{$aadFieldName}})
	}
	s.{{$fieldName}} = encrypted{{$fieldName}}
{{ end }}
	return nil
}

func (s *{{$structName}}) AfterFind(tx *gorm.DB) error {
	decrypt := s.getCipherForDb(tx).Decrypt
{{ range $encryptedField := $encryptedStruct.Fields -}}
	{{- $fieldName := $encryptedField.FieldName}}
	{{- $aadFieldName := $encryptedField.AadFieldName}}
	encrypted{{$fieldName}} := s.{{$fieldName}}
	plain{{$fieldName}}, err := decrypt([]byte(s.{{$aadFieldName}}), encrypted{{$fieldName}})
	if err != nil {
		return fmt.Errorf("{{$fieldName}} decryption failed for {{$aadFieldName}}=%q", s.{{$aadFieldName}})
	}
	s.{{$fieldName}} = plain{{$fieldName}}
{{ end }}
	return nil
}

func (s *{{$structName}}) AfterCreate(tx *gorm.DB) error {
	decrypt := s.getCipherForDb(tx).Decrypt
{{ range $encryptedField := $encryptedStruct.Fields -}}
	{{- $fieldName := $encryptedField.FieldName}}
	{{- $aadFieldName := $encryptedField.AadFieldName}}
	encrypted{{$fieldName}} := s.{{$fieldName}}
	plain{{$fieldName}}, err := decrypt([]byte(s.{{$aadFieldName}}), encrypted{{$fieldName}})
	if err != nil {
		return fmt.Errorf("{{$fieldName}} decryption failed for {{$aadFieldName}}=%q", s.{{$aadFieldName}})
	}
	s.{{$fieldName}} = plain{{$fieldName}}
{{ end }}
	return nil
}

func (s *{{$encryptedStruct.StructName}}) getCipherForDb(tx *gorm.DB) slosilo.SymmetricCipher {
	cipher, ok := tx.Statement.Context.Value("cipher").(slosilo.SymmetricCipher)
	if !ok || cipher == nil {
		panic("no cipher in database context")
	}

	return cipher
}
{{- end}}
`

type EncryptedStruct struct {
	StructName string
	Fields     []EncryptedField
}
type EncryptedField struct {
	FieldName    string
	AadFieldName string
}

func main() {
	flag.Parse()

	fset := token.NewFileSet()

	ff, err := parser.ParseDir(fset, ".", nil, parser.ParseComments)
	if err != nil {
		panic(err)
	}

	for _, p := range ff {
		for filename, f := range p.Files {

			encryptedStructs := []EncryptedStruct{}
			for _, node := range f.Decls {
				switch node.(type) {

				case *ast.GenDecl:
					genDecl := node.(*ast.GenDecl)
					for _, spec := range genDecl.Specs {
						switch spec.(type) {
						case *ast.TypeSpec:
							typeSpec := spec.(*ast.TypeSpec)

							// fmt.Printf("Struct: name=%s\n", typeSpec.Name.Name)

							encryptedStruct := EncryptedStruct{
								StructName: typeSpec.Name.Name,
							}
							switch structType := typeSpec.Type.(type) {
							case *ast.StructType:
								for _, field := range structType.Fields.List {

									for _, name := range field.Names {
										var tagRaw string
										if field.Tag != nil {
											tagRaw = field.Tag.Value[1 : len(field.Tag.Value)-1]
										}

										tag := reflect.StructTag(tagRaw)

										tags := map[string]string{}
										for _, tagPair := range strings.Split(tag.Get("slosilo"), ";") {
											splitTagPair := strings.SplitN(tagPair, ":", 2)

											if len(splitTagPair) == 1 {
												if splitTagPair[0] == "" {
													continue
												}
												splitTagPair = append(splitTagPair, "")
											}
											tags[splitTagPair[0]] = splitTagPair[1]
										}
										if _, ok := tags["encrypted"]; !ok {
											continue
										}

										encryptedStruct.Fields = append(encryptedStruct.Fields, EncryptedField{
											FieldName:    name.Name,
											AadFieldName: tags["aad"],
										})
									}

								}

							}

							if len(encryptedStruct.Fields) > 0 {
								encryptedStructs = append(encryptedStructs, encryptedStruct)
							}
						}
					}
				}
			}

			if len(encryptedStructs) == 0 {
				continue
			}

			tt := template.Must(template.New("queue").Parse(tpl))
			for i := 0; i < len(os.Args); i++ {
				dest := strings.ReplaceAll(filename, ".go", "_encrypted.go")
				file, err := os.Create(dest)
				if err != nil {
					fmt.Printf("Could not create %s: %s (skip) \n", dest, err)
					continue
				}

				vals := map[string]interface{}{
					"EncryptedStructs": encryptedStructs,
					"Package":          p.Name,
				}
				tt.Execute(file, vals)
				file.Close()
			}
		}
	}
}
