// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gorilla/mux"
	"github.com/oapi-codegen/runtime"
)

const (
	BasicAuthScopes  = "basicAuth.Scopes"
	BearerAuthScopes = "bearerAuth.Scopes"
)

// AccountCreateResponse defines model for AccountCreateResponse.
type AccountCreateResponse struct {
	ApiKey *string `json:"api_key,omitempty"`
	Id     *string `json:"id,omitempty"`
}

// AuthenticatorsResponse defines model for AuthenticatorsResponse.
type AuthenticatorsResponse struct {
	Configured *[]string `json:"configured,omitempty"`
	Enabled    *[]string `json:"enabled,omitempty"`
	Installed  *[]string `json:"installed,omitempty"`
	Status     *string   `json:"status,omitempty"`
}

// MembershipGrant defines model for MembershipGrant.
type MembershipGrant struct {
	AdminOption *bool   `json:"admin_option,omitempty"`
	Member      *string `json:"member,omitempty"`
	Ownership   *bool   `json:"ownership,omitempty"`
	Policy      *string `json:"policy,omitempty"`
	Role        *string `json:"role,omitempty"`
}

// PolicyLoadResponse defines model for PolicyLoadResponse.
type PolicyLoadResponse struct {
	CreatedRoles *map[string]struct {
		ApiKey *string `json:"api_key,omitempty"`
		Id     *string `json:"id,omitempty"`
	} `json:"created_roles,omitempty"`
	DryRun  *bool `json:"dry_run,omitempty"`
	Version *int  `json:"version,omitempty"`
}

// PolicyVersion defines model for PolicyVersion.
type PolicyVersion struct {
	ClientIp     *string    `json:"client_ip,omitempty"`
	CreatedAt    *time.Time `json:"created_at,omitempty"`
	FinishedAt   *time.Time `json:"finished_at,omitempty"`
	PolicySha256 *string    `json:"policy_sha256,omitempty"`
	RoleId       *string    `json:"role_id,omitempty"`
	Version      *int       `json:"version,omitempty"`
}

// Resource defines model for Resource.
type Resource struct {
	Annotations *map[string]string        `json:"annotations,omitempty"`
	Id          *string                   `json:"id,omitempty"`
	Owner       *string                   `json:"owner,omitempty"`
	Permissions *[]map[string]interface{} `json:"permissions,omitempty"`
	Policy      *string                   `json:"policy,omitempty"`
}

// Role defines model for Role.
type Role struct {
	Id      *string            `json:"id,omitempty"`
	Members *[]MembershipGrant `json:"members,omitempty"`
}

// WhoAmI defines model for WhoAmI.
type WhoAmI struct {
	Account       string     `json:"account"`
	ClientIp      *string    `json:"client_ip,omitempty"`
	TokenIssuedAt *time.Time `json:"token_issued_at,omitempty"`
	Username      string     `json:"username"`
}

// Account defines model for Account.
type Account = string

// AccountId defines model for AccountId.
type AccountId = string

// Authenticator defines model for Authenticator.
type Authenticator = string

// Identifier defines model for Identifier.
type Identifier = string

// Kind defines model for Kind.
type Kind = string

// Login defines model for Login.
type Login = string

// ServiceId defines model for ServiceId.
type ServiceId = string

// CreateAccountJSONBody defines parameters for CreateAccount.
type CreateAccountJSONBody struct {
	Id *string `json:"id,omitempty"`
}

// CreateAccountParams defines parameters for CreateAccount.
type CreateAccountParams struct {
	// Id Account name
	Id *string `form:"id,omitempty" json:"id,omitempty"`
}

// AuthenticateJwtFormdataBody defines parameters for AuthenticateJwt.
type AuthenticateJwtFormdataBody struct {
	Jwt *string `form:"jwt,omitempty" json:"jwt,omitempty"`
}

// RotateApiKeyParams defines parameters for RotateApiKey.
type RotateApiKeyParams struct {
	// Role Target role to rotate key for
	Role *string `form:"role,omitempty" json:"role,omitempty"`
}

// ChangePasswordTextBody defines parameters for ChangePassword.
type ChangePasswordTextBody = string

// AuthenticateTextBody defines parameters for Authenticate.
type AuthenticateTextBody = string

// GetPolicyParams defines parameters for GetPolicy.
type GetPolicyParams struct {
	// Version Specific version to retrieve
	Version *int `form:"version,omitempty" json:"version,omitempty"`
}

// UpdatePolicyTextBody defines parameters for UpdatePolicy.
type UpdatePolicyTextBody = string

// UpdatePolicyParams defines parameters for UpdatePolicy.
type UpdatePolicyParams struct {
	DryRun *bool `form:"dry_run,omitempty" json:"dry_run,omitempty"`
}

// LoadPolicyTextBody defines parameters for LoadPolicy.
type LoadPolicyTextBody = string

// LoadPolicyParams defines parameters for LoadPolicy.
type LoadPolicyParams struct {
	// DryRun Validate without applying
	DryRun *bool `form:"dry_run,omitempty" json:"dry_run,omitempty"`
}

// ReplacePolicyTextBody defines parameters for ReplacePolicy.
type ReplacePolicyTextBody = string

// ReplacePolicyParams defines parameters for ReplacePolicy.
type ReplacePolicyParams struct {
	DryRun *bool `form:"dry_run,omitempty" json:"dry_run,omitempty"`
}

// ListResourcesParams defines parameters for ListResources.
type ListResourcesParams struct {
	Kind   *string `form:"kind,omitempty" json:"kind,omitempty"`
	Search *string `form:"search,omitempty" json:"search,omitempty"`
	Limit  *int    `form:"limit,omitempty" json:"limit,omitempty"`
	Offset *int    `form:"offset,omitempty" json:"offset,omitempty"`
	Count  *bool   `form:"count,omitempty" json:"count,omitempty"`
}

// ListResourcesByKindParams defines parameters for ListResourcesByKind.
type ListResourcesByKindParams struct {
	Search *string `form:"search,omitempty" json:"search,omitempty"`
	Limit  *int    `form:"limit,omitempty" json:"limit,omitempty"`
	Offset *int    `form:"offset,omitempty" json:"offset,omitempty"`
}

// GetResourceParams defines parameters for GetResource.
type GetResourceParams struct {
	// Check If true, check permission instead of fetching resource
	Check *bool `form:"check,omitempty" json:"check,omitempty"`

	// Privilege Required with check=true
	Privilege *string `form:"privilege,omitempty" json:"privilege,omitempty"`

	// Role Role to check permission for
	Role *string `form:"role,omitempty" json:"role,omitempty"`

	// PermittedRoles If present, return roles with the specified privilege
	PermittedRoles *bool `form:"permitted_roles,omitempty" json:"permitted_roles,omitempty"`
}

// DeleteRoleMemberParams defines parameters for DeleteRoleMember.
type DeleteRoleMemberParams struct {
	// Members Required flag to indicate member operation
	Members string `form:"members" json:"members"`

	// Member Member role ID to remove
	Member string `form:"member" json:"member"`
}

// GetRoleParams defines parameters for GetRole.
type GetRoleParams struct {
	// Members If present, return role members
	Members *bool `form:"members,omitempty" json:"members,omitempty"`

	// Memberships If present, return role memberships
	Memberships *bool `form:"memberships,omitempty" json:"memberships,omitempty"`

	// All If present with memberships, return all transitive memberships
	All *bool `form:"all,omitempty" json:"all,omitempty"`

	// Count Return count instead of list
	Count  *bool   `form:"count,omitempty" json:"count,omitempty"`
	Search *string `form:"search,omitempty" json:"search,omitempty"`
	Limit  *int    `form:"limit,omitempty" json:"limit,omitempty"`
	Offset *int    `form:"offset,omitempty" json:"offset,omitempty"`
}

// AddRoleMemberParams defines parameters for AddRoleMember.
type AddRoleMemberParams struct {
	// Members Required flag to indicate member operation
	Members string `form:"members" json:"members"`

	// Member Member role ID to add
	Member string `form:"member" json:"member"`
}

// BatchGetSecretsParams defines parameters for BatchGetSecrets.
type BatchGetSecretsParams struct {
	// VariableIds Comma-separated list of variable IDs
	VariableIds string `form:"variable_ids" json:"variable_ids"`
}

// BatchUpdateSecretsJSONBody defines parameters for BatchUpdateSecrets.
type BatchUpdateSecretsJSONBody struct {
	Secrets *map[string]string `json:"secrets,omitempty"`
}

// GetSecretParams defines parameters for GetSecret.
type GetSecretParams struct {
	// Version Secret version (default latest)
	Version *int `form:"version,omitempty" json:"version,omitempty"`
}

// CreateSecretParams defines parameters for CreateSecret.
type CreateSecretParams struct {
	// Expirations If present, expire the secret instead of setting value
	Expirations *string `form:"expirations,omitempty" json:"expirations,omitempty"`
}

// CreateAccountJSONRequestBody defines body for CreateAccount for application/json ContentType.
type CreateAccountJSONRequestBody CreateAccountJSONBody

// AuthenticateJwtFormdataRequestBody defines body for AuthenticateJwt for application/x-www-form-urlencoded ContentType.
type AuthenticateJwtFormdataRequestBody AuthenticateJwtFormdataBody

// ChangePasswordTextRequestBody defines body for ChangePassword for text/plain ContentType.
type ChangePasswordTextRequestBody = ChangePasswordTextBody

// AuthenticateTextRequestBody defines body for Authenticate for text/plain ContentType.
type AuthenticateTextRequestBody = AuthenticateTextBody

// UpdatePolicyTextRequestBody defines body for UpdatePolicy for text/plain ContentType.
type UpdatePolicyTextRequestBody = UpdatePolicyTextBody

// LoadPolicyTextRequestBody defines body for LoadPolicy for text/plain ContentType.
type LoadPolicyTextRequestBody = LoadPolicyTextBody

// ReplacePolicyTextRequestBody defines body for ReplacePolicy for text/plain ContentType.
type ReplacePolicyTextRequestBody = ReplacePolicyTextBody

// BatchUpdateSecretsJSONRequestBody defines body for BatchUpdateSecrets for application/json ContentType.
type BatchUpdateSecretsJSONRequestBody BatchUpdateSecretsJSONBody

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Server status page
	// (GET /)
	GetStatus(w http.ResponseWriter, r *http.Request)
	// List all accounts
	// (GET /accounts)
	ListAccounts(w http.ResponseWriter, r *http.Request)
	// Create a new account
	// (POST /accounts)
	CreateAccount(w http.ResponseWriter, r *http.Request, params CreateAccountParams)
	// Delete an account
	// (DELETE /accounts/{id})
	DeleteAccount(w http.ResponseWriter, r *http.Request, id AccountId)
	// List installed authenticators
	// (GET /authenticators)
	GetAuthenticators(w http.ResponseWriter, r *http.Request)
	// Authenticate using JWT
	// (POST /authn-jwt/{service_id}/{account}/authenticate)
	AuthenticateJwt(w http.ResponseWriter, r *http.Request, serviceId ServiceId, account Account)
	// Rotate API key
	// (PUT /authn/{account}/api_key)
	RotateApiKey(w http.ResponseWriter, r *http.Request, account Account, params RotateApiKeyParams)
	// Get API key for a user
	// (GET /authn/{account}/login)
	Login(w http.ResponseWriter, r *http.Request, account Account)
	// Change password
	// (PUT /authn/{account}/password)
	ChangePassword(w http.ResponseWriter, r *http.Request, account Account)
	// Authenticate and get access token
	// (POST /authn/{account}/{login}/authenticate)
	Authenticate(w http.ResponseWriter, r *http.Request, account Account, login Login)
	// Get policy versions
	// (GET /policies/{account}/policy/{identifier})
	GetPolicy(w http.ResponseWriter, r *http.Request, account Account, identifier Identifier, params GetPolicyParams)
	// Update existing policy
	// (PATCH /policies/{account}/policy/{identifier})
	UpdatePolicy(w http.ResponseWriter, r *http.Request, account Account, identifier Identifier, params UpdatePolicyParams)
	// Append to existing policy
	// (POST /policies/{account}/policy/{identifier})
	LoadPolicy(w http.ResponseWriter, r *http.Request, account Account, identifier Identifier, params LoadPolicyParams)
	// Replace existing policy
	// (PUT /policies/{account}/policy/{identifier})
	ReplacePolicy(w http.ResponseWriter, r *http.Request, account Account, identifier Identifier, params ReplacePolicyParams)
	// List resources in account
	// (GET /resources/{account})
	ListResources(w http.ResponseWriter, r *http.Request, account Account, params ListResourcesParams)
	// List resources by kind
	// (GET /resources/{account}/{kind})
	ListResourcesByKind(w http.ResponseWriter, r *http.Request, account Account, kind Kind, params ListResourcesByKindParams)
	// Get a specific resource
	// (GET /resources/{account}/{kind}/{identifier})
	GetResource(w http.ResponseWriter, r *http.Request, account Account, kind Kind, identifier Identifier, params GetResourceParams)
	// Remove member from role
	// (DELETE /roles/{account}/{kind}/{identifier})
	DeleteRoleMember(w http.ResponseWriter, r *http.Request, account Account, kind Kind, identifier Identifier, params DeleteRoleMemberParams)
	// Get role details
	// (GET /roles/{account}/{kind}/{identifier})
	GetRole(w http.ResponseWriter, r *http.Request, account Account, kind Kind, identifier Identifier, params GetRoleParams)
	// Add member to role
	// (POST /roles/{account}/{kind}/{identifier})
	AddRoleMember(w http.ResponseWriter, r *http.Request, account Account, kind Kind, identifier Identifier, params AddRoleMemberParams)
	// Fetch multiple secrets
	// (GET /secrets)
	BatchGetSecrets(w http.ResponseWriter, r *http.Request, params BatchGetSecretsParams)
	// Update multiple secrets
	// (POST /secrets/{account}/values)
	BatchUpdateSecrets(w http.ResponseWriter, r *http.Request, account Account)
	// Fetch a secret value
	// (GET /secrets/{account}/{kind}/{identifier})
	GetSecret(w http.ResponseWriter, r *http.Request, account Account, kind Kind, identifier Identifier, params GetSecretParams)
	// Create or update a secret value, or expire it
	// (POST /secrets/{account}/{kind}/{identifier})
	CreateSecret(w http.ResponseWriter, r *http.Request, account Account, kind Kind, identifier Identifier, params CreateSecretParams)
	// Returns information about the authenticated identity
	// (GET /whoami)
	Whoami(w http.ResponseWriter, r *http.Request)
	// Get authenticator status
	// (GET /{authenticator}/{account}/status)
	GetAuthenticatorStatus(w http.ResponseWriter, r *http.Request, authenticator Authenticator, account Account)
	// Get authenticator service status
	// (GET /{authenticator}/{service_id}/{account}/status)
	GetAuthenticatorServiceStatus(w http.ResponseWriter, r *http.Request, authenticator Authenticator, serviceId ServiceId, account Account)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// GetStatus operation middleware
func (siw *ServerInterfaceWrapper) GetStatus(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetStatus(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListAccounts operation middleware
func (siw *ServerInterfaceWrapper) ListAccounts(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListAccounts(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateAccount operation middleware
func (siw *ServerInterfaceWrapper) CreateAccount(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateAccountParams

	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", r.URL.Query(), &params.Id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateAccount(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteAccount operation middleware
func (siw *ServerInterfaceWrapper) DeleteAccount(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id AccountId

	err = runtime.BindStyledParameterWithOptions("simple", "id", mux.Vars(r)["id"], &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteAccount(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetAuthenticators operation middleware
func (siw *ServerInterfaceWrapper) GetAuthenticators(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetAuthenticators(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AuthenticateJwt operation middleware
func (siw *ServerInterfaceWrapper) AuthenticateJwt(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "service_id" -------------
	var serviceId ServiceId

	err = runtime.BindStyledParameterWithOptions("simple", "service_id", mux.Vars(r)["service_id"], &serviceId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "service_id", Err: err})
		return
	}

	// ------------- Path parameter "account" -------------
	var account Account

	err = runtime.BindStyledParameterWithOptions("simple", "account", mux.Vars(r)["account"], &account, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "account", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AuthenticateJwt(w, r, serviceId, account)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// RotateApiKey operation middleware
func (siw *ServerInterfaceWrapper) RotateApiKey(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "account" -------------
	var account Account

	err = runtime.BindStyledParameterWithOptions("simple", "account", mux.Vars(r)["account"], &account, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "account", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params RotateApiKeyParams

	// ------------- Optional query parameter "role" -------------

	err = runtime.BindQueryParameter("form", true, false, "role", r.URL.Query(), &params.Role)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "role", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RotateApiKey(w, r, account, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// Login operation middleware
func (siw *ServerInterfaceWrapper) Login(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "account" -------------
	var account Account

	err = runtime.BindStyledParameterWithOptions("simple", "account", mux.Vars(r)["account"], &account, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "account", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Login(w, r, account)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ChangePassword operation middleware
func (siw *ServerInterfaceWrapper) ChangePassword(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "account" -------------
	var account Account

	err = runtime.BindStyledParameterWithOptions("simple", "account", mux.Vars(r)["account"], &account, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "account", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ChangePassword(w, r, account)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// Authenticate operation middleware
func (siw *ServerInterfaceWrapper) Authenticate(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "account" -------------
	var account Account

	err = runtime.BindStyledParameterWithOptions("simple", "account", mux.Vars(r)["account"], &account, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "account", Err: err})
		return
	}

	// ------------- Path parameter "login" -------------
	var login Login

	err = runtime.BindStyledParameterWithOptions("simple", "login", mux.Vars(r)["login"], &login, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "login", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Authenticate(w, r, account, login)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetPolicy operation middleware
func (siw *ServerInterfaceWrapper) GetPolicy(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "account" -------------
	var account Account

	err = runtime.BindStyledParameterWithOptions("simple", "account", mux.Vars(r)["account"], &account, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "account", Err: err})
		return
	}

	// ------------- Path parameter "identifier" -------------
	var identifier Identifier

	err = runtime.BindStyledParameterWithOptions("simple", "identifier", mux.Vars(r)["identifier"], &identifier, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "identifier", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPolicyParams

	// ------------- Optional query parameter "version" -------------

	err = runtime.BindQueryParameter("form", true, false, "version", r.URL.Query(), &params.Version)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "version", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetPolicy(w, r, account, identifier, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdatePolicy operation middleware
func (siw *ServerInterfaceWrapper) UpdatePolicy(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "account" -------------
	var account Account

	err = runtime.BindStyledParameterWithOptions("simple", "account", mux.Vars(r)["account"], &account, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "account", Err: err})
		return
	}

	// ------------- Path parameter "identifier" -------------
	var identifier Identifier

	err = runtime.BindStyledParameterWithOptions("simple", "identifier", mux.Vars(r)["identifier"], &identifier, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "identifier", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdatePolicyParams

	// ------------- Optional query parameter "dry_run" -------------

	err = runtime.BindQueryParameter("form", true, false, "dry_run", r.URL.Query(), &params.DryRun)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "dry_run", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdatePolicy(w, r, account, identifier, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// LoadPolicy operation middleware
func (siw *ServerInterfaceWrapper) LoadPolicy(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "account" -------------
	var account Account

	err = runtime.BindStyledParameterWithOptions("simple", "account", mux.Vars(r)["account"], &account, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "account", Err: err})
		return
	}

	// ------------- Path parameter "identifier" -------------
	var identifier Identifier

	err = runtime.BindStyledParameterWithOptions("simple", "identifier", mux.Vars(r)["identifier"], &identifier, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "identifier", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params LoadPolicyParams

	// ------------- Optional query parameter "dry_run" -------------

	err = runtime.BindQueryParameter("form", true, false, "dry_run", r.URL.Query(), &params.DryRun)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "dry_run", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.LoadPolicy(w, r, account, identifier, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ReplacePolicy operation middleware
func (siw *ServerInterfaceWrapper) ReplacePolicy(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "account" -------------
	var account Account

	err = runtime.BindStyledParameterWithOptions("simple", "account", mux.Vars(r)["account"], &account, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "account", Err: err})
		return
	}

	// ------------- Path parameter "identifier" -------------
	var identifier Identifier

	err = runtime.BindStyledParameterWithOptions("simple", "identifier", mux.Vars(r)["identifier"], &identifier, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "identifier", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ReplacePolicyParams

	// ------------- Optional query parameter "dry_run" -------------

	err = runtime.BindQueryParameter("form", true, false, "dry_run", r.URL.Query(), &params.DryRun)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "dry_run", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ReplacePolicy(w, r, account, identifier, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListResources operation middleware
func (siw *ServerInterfaceWrapper) ListResources(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "account" -------------
	var account Account

	err = runtime.BindStyledParameterWithOptions("simple", "account", mux.Vars(r)["account"], &account, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "account", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListResourcesParams

	// ------------- Optional query parameter "kind" -------------

	err = runtime.BindQueryParameter("form", true, false, "kind", r.URL.Query(), &params.Kind)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "kind", Err: err})
		return
	}

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	// ------------- Optional query parameter "count" -------------

	err = runtime.BindQueryParameter("form", true, false, "count", r.URL.Query(), &params.Count)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "count", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListResources(w, r, account, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListResourcesByKind operation middleware
func (siw *ServerInterfaceWrapper) ListResourcesByKind(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "account" -------------
	var account Account

	err = runtime.BindStyledParameterWithOptions("simple", "account", mux.Vars(r)["account"], &account, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "account", Err: err})
		return
	}

	// ------------- Path parameter "kind" -------------
	var kind Kind

	err = runtime.BindStyledParameterWithOptions("simple", "kind", mux.Vars(r)["kind"], &kind, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "kind", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListResourcesByKindParams

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListResourcesByKind(w, r, account, kind, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetResource operation middleware
func (siw *ServerInterfaceWrapper) GetResource(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "account" -------------
	var account Account

	err = runtime.BindStyledParameterWithOptions("simple", "account", mux.Vars(r)["account"], &account, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "account", Err: err})
		return
	}

	// ------------- Path parameter "kind" -------------
	var kind Kind

	err = runtime.BindStyledParameterWithOptions("simple", "kind", mux.Vars(r)["kind"], &kind, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "kind", Err: err})
		return
	}

	// ------------- Path parameter "identifier" -------------
	var identifier Identifier

	err = runtime.BindStyledParameterWithOptions("simple", "identifier", mux.Vars(r)["identifier"], &identifier, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "identifier", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetResourceParams

	// ------------- Optional query parameter "check" -------------

	err = runtime.BindQueryParameter("form", true, false, "check", r.URL.Query(), &params.Check)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "check", Err: err})
		return
	}

	// ------------- Optional query parameter "privilege" -------------

	err = runtime.BindQueryParameter("form", true, false, "privilege", r.URL.Query(), &params.Privilege)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "privilege", Err: err})
		return
	}

	// ------------- Optional query parameter "role" -------------

	err = runtime.BindQueryParameter("form", true, false, "role", r.URL.Query(), &params.Role)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "role", Err: err})
		return
	}

	// ------------- Optional query parameter "permitted_roles" -------------

	err = runtime.BindQueryParameter("form", true, false, "permitted_roles", r.URL.Query(), &params.PermittedRoles)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "permitted_roles", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetResource(w, r, account, kind, identifier, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteRoleMember operation middleware
func (siw *ServerInterfaceWrapper) DeleteRoleMember(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "account" -------------
	var account Account

	err = runtime.BindStyledParameterWithOptions("simple", "account", mux.Vars(r)["account"], &account, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "account", Err: err})
		return
	}

	// ------------- Path parameter "kind" -------------
	var kind Kind

	err = runtime.BindStyledParameterWithOptions("simple", "kind", mux.Vars(r)["kind"], &kind, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "kind", Err: err})
		return
	}

	// ------------- Path parameter "identifier" -------------
	var identifier Identifier

	err = runtime.BindStyledParameterWithOptions("simple", "identifier", mux.Vars(r)["identifier"], &identifier, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "identifier", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteRoleMemberParams

	// ------------- Required query parameter "members" -------------

	if paramValue := r.URL.Query().Get("members"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "members"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "members", r.URL.Query(), &params.Members)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "members", Err: err})
		return
	}

	// ------------- Required query parameter "member" -------------

	if paramValue := r.URL.Query().Get("member"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "member"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "member", r.URL.Query(), &params.Member)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "member", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteRoleMember(w, r, account, kind, identifier, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetRole operation middleware
func (siw *ServerInterfaceWrapper) GetRole(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "account" -------------
	var account Account

	err = runtime.BindStyledParameterWithOptions("simple", "account", mux.Vars(r)["account"], &account, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "account", Err: err})
		return
	}

	// ------------- Path parameter "kind" -------------
	var kind Kind

	err = runtime.BindStyledParameterWithOptions("simple", "kind", mux.Vars(r)["kind"], &kind, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "kind", Err: err})
		return
	}

	// ------------- Path parameter "identifier" -------------
	var identifier Identifier

	err = runtime.BindStyledParameterWithOptions("simple", "identifier", mux.Vars(r)["identifier"], &identifier, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "identifier", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetRoleParams

	// ------------- Optional query parameter "members" -------------

	err = runtime.BindQueryParameter("form", true, false, "members", r.URL.Query(), &params.Members)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "members", Err: err})
		return
	}

	// ------------- Optional query parameter "memberships" -------------

	err = runtime.BindQueryParameter("form", true, false, "memberships", r.URL.Query(), &params.Memberships)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "memberships", Err: err})
		return
	}

	// ------------- Optional query parameter "all" -------------

	err = runtime.BindQueryParameter("form", true, false, "all", r.URL.Query(), &params.All)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "all", Err: err})
		return
	}

	// ------------- Optional query parameter "count" -------------

	err = runtime.BindQueryParameter("form", true, false, "count", r.URL.Query(), &params.Count)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "count", Err: err})
		return
	}

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetRole(w, r, account, kind, identifier, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AddRoleMember operation middleware
func (siw *ServerInterfaceWrapper) AddRoleMember(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "account" -------------
	var account Account

	err = runtime.BindStyledParameterWithOptions("simple", "account", mux.Vars(r)["account"], &account, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "account", Err: err})
		return
	}

	// ------------- Path parameter "kind" -------------
	var kind Kind

	err = runtime.BindStyledParameterWithOptions("simple", "kind", mux.Vars(r)["kind"], &kind, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "kind", Err: err})
		return
	}

	// ------------- Path parameter "identifier" -------------
	var identifier Identifier

	err = runtime.BindStyledParameterWithOptions("simple", "identifier", mux.Vars(r)["identifier"], &identifier, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "identifier", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params AddRoleMemberParams

	// ------------- Required query parameter "members" -------------

	if paramValue := r.URL.Query().Get("members"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "members"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "members", r.URL.Query(), &params.Members)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "members", Err: err})
		return
	}

	// ------------- Required query parameter "member" -------------

	if paramValue := r.URL.Query().Get("member"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "member"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "member", r.URL.Query(), &params.Member)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "member", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddRoleMember(w, r, account, kind, identifier, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// BatchGetSecrets operation middleware
func (siw *ServerInterfaceWrapper) BatchGetSecrets(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params BatchGetSecretsParams

	// ------------- Required query parameter "variable_ids" -------------

	if paramValue := r.URL.Query().Get("variable_ids"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "variable_ids"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "variable_ids", r.URL.Query(), &params.VariableIds)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "variable_ids", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.BatchGetSecrets(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// BatchUpdateSecrets operation middleware
func (siw *ServerInterfaceWrapper) BatchUpdateSecrets(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "account" -------------
	var account Account

	err = runtime.BindStyledParameterWithOptions("simple", "account", mux.Vars(r)["account"], &account, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "account", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.BatchUpdateSecrets(w, r, account)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetSecret operation middleware
func (siw *ServerInterfaceWrapper) GetSecret(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "account" -------------
	var account Account

	err = runtime.BindStyledParameterWithOptions("simple", "account", mux.Vars(r)["account"], &account, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "account", Err: err})
		return
	}

	// ------------- Path parameter "kind" -------------
	var kind Kind

	err = runtime.BindStyledParameterWithOptions("simple", "kind", mux.Vars(r)["kind"], &kind, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "kind", Err: err})
		return
	}

	// ------------- Path parameter "identifier" -------------
	var identifier Identifier

	err = runtime.BindStyledParameterWithOptions("simple", "identifier", mux.Vars(r)["identifier"], &identifier, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "identifier", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSecretParams

	// ------------- Optional query parameter "version" -------------

	err = runtime.BindQueryParameter("form", true, false, "version", r.URL.Query(), &params.Version)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "version", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSecret(w, r, account, kind, identifier, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateSecret operation middleware
func (siw *ServerInterfaceWrapper) CreateSecret(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "account" -------------
	var account Account

	err = runtime.BindStyledParameterWithOptions("simple", "account", mux.Vars(r)["account"], &account, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "account", Err: err})
		return
	}

	// ------------- Path parameter "kind" -------------
	var kind Kind

	err = runtime.BindStyledParameterWithOptions("simple", "kind", mux.Vars(r)["kind"], &kind, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "kind", Err: err})
		return
	}

	// ------------- Path parameter "identifier" -------------
	var identifier Identifier

	err = runtime.BindStyledParameterWithOptions("simple", "identifier", mux.Vars(r)["identifier"], &identifier, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "identifier", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateSecretParams

	// ------------- Optional query parameter "expirations" -------------

	err = runtime.BindQueryParameter("form", true, false, "expirations", r.URL.Query(), &params.Expirations)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "expirations", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateSecret(w, r, account, kind, identifier, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// Whoami operation middleware
func (siw *ServerInterfaceWrapper) Whoami(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Whoami(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetAuthenticatorStatus operation middleware
func (siw *ServerInterfaceWrapper) GetAuthenticatorStatus(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "authenticator" -------------
	var authenticator Authenticator

	err = runtime.BindStyledParameterWithOptions("simple", "authenticator", mux.Vars(r)["authenticator"], &authenticator, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "authenticator", Err: err})
		return
	}

	// ------------- Path parameter "account" -------------
	var account Account

	err = runtime.BindStyledParameterWithOptions("simple", "account", mux.Vars(r)["account"], &account, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "account", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetAuthenticatorStatus(w, r, authenticator, account)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetAuthenticatorServiceStatus operation middleware
func (siw *ServerInterfaceWrapper) GetAuthenticatorServiceStatus(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "authenticator" -------------
	var authenticator Authenticator

	err = runtime.BindStyledParameterWithOptions("simple", "authenticator", mux.Vars(r)["authenticator"], &authenticator, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "authenticator", Err: err})
		return
	}

	// ------------- Path parameter "service_id" -------------
	var serviceId ServiceId

	err = runtime.BindStyledParameterWithOptions("simple", "service_id", mux.Vars(r)["service_id"], &serviceId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "service_id", Err: err})
		return
	}

	// ------------- Path parameter "account" -------------
	var account Account

	err = runtime.BindStyledParameterWithOptions("simple", "account", mux.Vars(r)["account"], &account, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "account", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetAuthenticatorServiceStatus(w, r, authenticator, serviceId, account)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, GorillaServerOptions{})
}

type GorillaServerOptions struct {
	BaseURL          string
	BaseRouter       *mux.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r *mux.Router) http.Handler {
	return HandlerWithOptions(si, GorillaServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r *mux.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, GorillaServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options GorillaServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = mux.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.HandleFunc(options.BaseURL+"/", wrapper.GetStatus).Methods("GET")

	r.HandleFunc(options.BaseURL+"/accounts", wrapper.ListAccounts).Methods("GET")

	r.HandleFunc(options.BaseURL+"/accounts", wrapper.CreateAccount).Methods("POST")

	r.HandleFunc(options.BaseURL+"/accounts/{id}", wrapper.DeleteAccount).Methods("DELETE")

	r.HandleFunc(options.BaseURL+"/authenticators", wrapper.GetAuthenticators).Methods("GET")

	r.HandleFunc(options.BaseURL+"/authn-jwt/{service_id}/{account}/authenticate", wrapper.AuthenticateJwt).Methods("POST")

	r.HandleFunc(options.BaseURL+"/authn/{account}/api_key", wrapper.RotateApiKey).Methods("PUT")

	r.HandleFunc(options.BaseURL+"/authn/{account}/login", wrapper.Login).Methods("GET")

	r.HandleFunc(options.BaseURL+"/authn/{account}/password", wrapper.ChangePassword).Methods("PUT")

	r.HandleFunc(options.BaseURL+"/authn/{account}/{login}/authenticate", wrapper.Authenticate).Methods("POST")

	r.HandleFunc(options.BaseURL+"/policies/{account}/policy/{identifier}", wrapper.GetPolicy).Methods("GET")

	r.HandleFunc(options.BaseURL+"/policies/{account}/policy/{identifier}", wrapper.UpdatePolicy).Methods("PATCH")

	r.HandleFunc(options.BaseURL+"/policies/{account}/policy/{identifier}", wrapper.LoadPolicy).Methods("POST")

	r.HandleFunc(options.BaseURL+"/policies/{account}/policy/{identifier}", wrapper.ReplacePolicy).Methods("PUT")

	r.HandleFunc(options.BaseURL+"/resources/{account}", wrapper.ListResources).Methods("GET")

	r.HandleFunc(options.BaseURL+"/resources/{account}/{kind}", wrapper.ListResourcesByKind).Methods("GET")

	r.HandleFunc(options.BaseURL+"/resources/{account}/{kind}/{identifier}", wrapper.GetResource).Methods("GET")

	r.HandleFunc(options.BaseURL+"/roles/{account}/{kind}/{identifier}", wrapper.DeleteRoleMember).Methods("DELETE")

	r.HandleFunc(options.BaseURL+"/roles/{account}/{kind}/{identifier}", wrapper.GetRole).Methods("GET")

	r.HandleFunc(options.BaseURL+"/roles/{account}/{kind}/{identifier}", wrapper.AddRoleMember).Methods("POST")

	r.HandleFunc(options.BaseURL+"/secrets", wrapper.BatchGetSecrets).Methods("GET")

	r.HandleFunc(options.BaseURL+"/secrets/{account}/values", wrapper.BatchUpdateSecrets).Methods("POST")

	r.HandleFunc(options.BaseURL+"/secrets/{account}/{kind}/{identifier}", wrapper.GetSecret).Methods("GET")

	r.HandleFunc(options.BaseURL+"/secrets/{account}/{kind}/{identifier}", wrapper.CreateSecret).Methods("POST")

	r.HandleFunc(options.BaseURL+"/whoami", wrapper.Whoami).Methods("GET")

	r.HandleFunc(options.BaseURL+"/{authenticator}/{account}/status", wrapper.GetAuthenticatorStatus).Methods("GET")

	r.HandleFunc(options.BaseURL+"/{authenticator}/{service_id}/{account}/status", wrapper.GetAuthenticatorServiceStatus).Methods("GET")

	return r
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
