// Auto-generated by gen/encrypted_models/main.go
package model

import (
	"fmt"

	"gorm.io/gorm"

	"conjur-in-go/pkg/slosilo"
)

func (s *Credential) BeforeCreate(tx *gorm.DB) error {
	encrypt := s.getCipherForDb(tx).Encrypt

	plainApiKey := s.ApiKey
	encryptedApiKey, err := encrypt([]byte(s.RoleId), plainApiKey)
	if err != nil {
		return fmt.Errorf("ApiKey encryption failed for RoleId=%q", s.RoleId)
	}
	s.ApiKey = encryptedApiKey

	plainEncryptedHash := s.EncryptedHash
	encryptedEncryptedHash, err := encrypt([]byte(s.RoleId), plainEncryptedHash)
	if err != nil {
		return fmt.Errorf("EncryptedHash encryption failed for RoleId=%q", s.RoleId)
	}
	s.EncryptedHash = encryptedEncryptedHash

	return nil
}

func (s *Credential) AfterFind(tx *gorm.DB) error {
	decrypt := s.getCipherForDb(tx).Decrypt

	encryptedApiKey := s.ApiKey
	plainApiKey, err := decrypt([]byte(s.RoleId), encryptedApiKey)
	if err != nil {
		return fmt.Errorf("ApiKey decryption failed for RoleId=%q", s.RoleId)
	}
	s.ApiKey = plainApiKey

	encryptedEncryptedHash := s.EncryptedHash
	plainEncryptedHash, err := decrypt([]byte(s.RoleId), encryptedEncryptedHash)
	if err != nil {
		return fmt.Errorf("EncryptedHash decryption failed for RoleId=%q", s.RoleId)
	}
	s.EncryptedHash = plainEncryptedHash

	return nil
}

func (s *Credential) AfterCreate(tx *gorm.DB) error {
	decrypt := s.getCipherForDb(tx).Decrypt

	encryptedApiKey := s.ApiKey
	plainApiKey, err := decrypt([]byte(s.RoleId), encryptedApiKey)
	if err != nil {
		return fmt.Errorf("ApiKey decryption failed for RoleId=%q", s.RoleId)
	}
	s.ApiKey = plainApiKey

	encryptedEncryptedHash := s.EncryptedHash
	plainEncryptedHash, err := decrypt([]byte(s.RoleId), encryptedEncryptedHash)
	if err != nil {
		return fmt.Errorf("EncryptedHash decryption failed for RoleId=%q", s.RoleId)
	}
	s.EncryptedHash = plainEncryptedHash

	return nil
}

func (s *Credential) getCipherForDb(tx *gorm.DB) slosilo.SymmetricCipher {
	cipher, ok := tx.Statement.Context.Value("cipher").(slosilo.SymmetricCipher)
	if !ok || cipher == nil {
		panic("no cipher in database context")
	}

	return cipher
}
